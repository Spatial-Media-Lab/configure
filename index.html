<!DOCTYPE html>
<html lang="en">

<head>
  <meta name="copyright" content="Kay Sievers, kay@vrfy.org">
  <meta name="revised" content="2021-01-24">
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <title>Spatial Media Lab - Device Configuration</title>
  <meta name="description" content="WebMIDI Device Configuration">
  <link rel="canonical" href="https://support.spatialmedialab.org/configure">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="thumbnail" content="icons/logo.png">
  <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
  <link rel="manifest" href="site.webmanifest">
  <link rel="stylesheet" href="css/bulma.min.css">
  <link rel="stylesheet" href="css/fonts.css">
  <link rel="stylesheet" href="css/fontawesome.min.css">
  <!--link rel="stylesheet" href="css/debug.css"-->
  <style>
    html {
      scroll-behavior: smooth;
      hyphens: auto;
      overflow: auto;
    }

    body {
      font-family: sans-serif;
    }

    /* Move content below the navbar */
    .topspace {
      margin-bottom: 3.25rem;
    }

    /* Avoid blue-colored Home/Brand */
    a.navbar-home:focus {
      color: #4a4a4a;
    }

    /* Do not mess with the DIN font, fake bold looks really ugly */
    .title {
      font-weight: 400;
    }

    .section {
      background-color: #f0f0f0;
      margin-top: 1.5rem;
      padding: 1rem;
    }

    /* Move anchors below the navbar */
    span.offset {
      display: block;
      position: relative;
      top: -4.25rem;
      visibility: hidden;
    }

    .subsection {
      margin-top: 2rem;
    }

    .inactive {
      pointer-events: none;
    }

    .button-keyboard {
      font-size: 0.75rem;
      height: 2.5rem;
      width: calc(1rem + 3.5vw);
    }

    .button-field {
      width: 6rem;
    }

    .button-note {
      width: 2.5rem;
    }

    .button-text {
      width: 12rem;
    }

    .input-number {
      width: 6rem;
    }

    .input-text {
      width: 15rem;
    }

    /* Disable touch events at the slider area; lists of sliders need to be scrollable. */
    @media (pointer: coarse) {
      input[type=range].range {
        pointer-events: none;
      }
    }

    input[type=range].range {
      -webkit-appearance: none;
      background: transparent;
      margin-bottom: 1.5rem;
      width: 100%;
    }

    input[type=range].range::-webkit-slider-runnable-track {
      height: 0.5rem;
      background: #dbdbdb;
      border: none;
      border-radius: 0.5rem;
    }

    input[type=range].range::-webkit-slider-thumb {
      pointer-events: auto;
      -webkit-appearance: none;
      border: none;
      height: 1.5rem;
      width: 1.5rem;
      border-radius: 50%;
      background: #363636;
      margin-top: -0.5rem;
      cursor: pointer;
    }

    input[type=range].range:disabled {
      opacity: 25%;
      cursor: not-allowed
    }

    input[type=range].range:focus {
      outline: none;
    }

    .log {
      height: 12rem;
      overflow: auto;
      background: white;
      padding: 1rem;
    }
  </style>
</head>

<body>
  <div class="topspace"></div>

  <!-- Navigation bar -->
  <nav class="navbar is-fixed-top" aria-label="navigation">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-home navbar-item is-size-4" href="#">
          <img class="mr-2" src="icons/logo.png" alt="Logo">
          <h1>
            Spatial Media Lab
          </h1>
        </a>
        <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>

      <div class="navbar-menu">
        <div class="navbar-start">
          <a class="navbar-item" href="#output">
            MIDI Out
          </a>
          <a class="navbar-item" href="#configuration">
            Configuration
          </a>
          <a class="navbar-item" href="#log">
            Log
          </a>
        </div>

        <div class="navbar-end">
          <a class="navbar-item" href="https://github.com/Spatial-Media-Lab/" title="Source Code" target="software">
            <span class="icon">
              <i class="fab fa-github"></i>
            </span>
          </a>
          <a class="navbar-item" href="https://spatialmedialab.org" title="spatialmedialab.org" target="home">
            <span class="icon">
              <i class="fas fa-home"></i>
            </span>
          </a>
        </div>
      </div>
    </div>
  </nav>
  <script>
    'use strict';

    // The menu/navigation.
    const home = document.querySelector('.navbar-home');
    const burger = document.querySelector('.navbar-burger');
    const menu = document.querySelector('.navbar-menu');

    // Close menu at Home/Brand.
    home.addEventListener('click', () => {
      burger.classList.remove('is-active');
      menu.classList.remove('is-active');
    })

    // Toggle menu with burger.
    burger.addEventListener('click', () => {
      burger.classList.toggle('is-active');
      menu.classList.toggle('is-active');
    })

    // Close menu at menu element click.
    menu.addEventListener('click', () => {
      burger.classList.remove('is-active');
      menu.classList.remove('is-active');
    })
  </script>

  <!-- MIDI system context -->
  <script>
    'use strict';

    // The MIDI system connection and message handling.
    const MIDI = Object.seal({
      // MIDI Note Number
      // The octave numbers -2 to 8 are not defined by MIDI itself, it's just what
      // some vendors of instruments and audio workstation software use. The middle
      // C (Number == 60) in this mapping is C3.
      Note: Object.freeze({
        names: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],

        name: function(note) {
          const octave = Math.trunc(note / 12) - 2;
          return this.names[note % 12] + octave;
        },

        isBlack: function(note) {
          return this.names[note % 12].includes('#');
        }
      }),

      // MIDI Control Change (CC) values.
      CC: Object.freeze({
        // MSB Controller Data.
        bankSelect: 0,
        modulationWheel: 1,
        breathController: 2,
        controller3: 3,
        footController: 4,
        portamentoTime: 5,
        dataEntry: 6,
        channelVolume: 7,
        balance: 8,
        controller9: 9,
        pan: 10,
        expression: 11,
        effectControl1: 12,
        effectControl2: 13,
        controller14: 14,
        controller15: 15,
        generalPurpose1: 16,
        generalPurpose2: 17,
        generalPurpose3: 18,
        generalPurpose4: 19,

        // LSB for controllers 0 to 31.
        controllerLSB: 32,
        bankSelectLSB: this.controllerLSB + this.bankSelect,
        modulationWheelLSB: this.controllerLSB + this.modulationWheel,
        breathControllerLSB: this.controllerLSB + this.breathController,
        controller3LSB: this.controllerLSB + this.controller3,
        footControllerLSB: this.controllerLSB + this.footController,
        portamentoTimeLSB: this.controllerLSB + this.portamentoTime,
        dataEntryLSB: this.controllerLSB + this.dataEntry,
        channelVolumeLSB: this.controllerLSB + this.channelVolume,
        balanceLSB: this.controllerLSB + this.balance,
        controller9LSB: this.controllerLSB + this.controller9,
        panLSB: this.controllerLSB + this.pan,
        expressionLSB: this.controllerLSB + this.expression,
        effectControl1LSB: this.controllerLSB + this.effectControl1,
        effectControl2LSB: this.controllerLSB + this.effectControl2,
        controller14LSB: this.controllerLSB + this.controller14,
        controller15LSB: this.controllerLSB + this.controller15,
        generalPurpose1LSB: this.controllerLSB + this.generalPurpose1,
        generalPurpose2LSB: this.controllerLSB + this.generalPurpose2,
        generalPurpose3LSB: this.controllerLSB + this.generalPurpose3,
        generalPurpose4LSB: this.controllerLSB + this.generalPurpose4,

        // Single-byte Controllers.
        sustain: 64,
        portamento: 65,
        sostenuto: 66,
        soft: 67,
        legato: 68,
        hold2: 69,
        soundController1: 70, // Sound Variation
        soundController2: 71, // Timber / Harmonic Intensity
        soundController3: 72, // Release Time
        soundController4: 73, // Attack Time
        soundController5: 74, // Brightness
        soundController6: 75, // Decay Time
        soundController7: 76, // Vibrato Rate
        soundController8: 77, // Vibrato Depth
        soundController9: 78, // Vibrato Delay
        soundController10: 79,
        generalPurpose5: 80, // Decay
        generalPurpose6: 81, // High Pass Filter Frequency
        generalPurpose7: 82,
        generalPurpose8: 83,
        portamentoControl: 84,
        controller85: 85,
        controller86: 86,
        controller87: 87,
        velocityPrefix: 88,
        controller89: 89,
        controller90: 90,
        effects1: 91, // Reverb Send
        effects2: 92, // Tremolo Depth
        effects3: 93, // Chorus Send
        effects4: 94, // Celeste Depth
        effects5: 95, // Phaser Depth

        // Increment/Decrement and Parameter numbers.
        dataIncrement: 96,
        dataDecrement: 97,
        NRPNLSB: 98,
        NRPNMSB: 99,
        RPNLSB: 100,
        RPNMSB: 101,

        controller102: 102,
        controller103: 103,
        controller104: 104,
        controller105: 105,
        controller106: 106,
        controller107: 107,
        controller108: 108,
        controller109: 109,
        controller110: 110,
        controller111: 111,
        controller112: 112,
        controller113: 113,
        controller114: 114,
        controller115: 115,
        controller116: 116,
        controller117: 117,
        controller118: 118,
        controller119: 119,

        // Channel Mode Message
        allSoundOff: 120,
        resetAllControllers: 121,
        localControl: 122,
        allNotesOff: 123,
        omniModeOff: 124,
        omniModeOn: 125,
        monoModeOn: 126,
        polyModeOn: 127
      }),

      // The MIDI wire protocol's status byte definitions.The first byte of a
      // message, the only byte with the 7th bit set. The lower 4 bit are the
      // channel number or the system message type.
      Status: Object.freeze({
        noteOff: 0x80 | (0 << 4),
        noteOn: 0x80 | (1 << 4),
        aftertouch: 0x80 | (2 << 4),
        controlChange: 0x80 | (3 << 4),
        programChange: 0x80 | (4 << 4),
        aftertouchChannel: 0x80 | (5 << 4),
        pitchBend: 0x80 | (6 << 4),
        system: 0x80 | (7 << 4),

        // The 'system' messages are device global, the channel number
        // indentifies the type of system message.
        systemExclusive: 0x80 | (7 << 4) | 0,
        systemTimeCodeQuarterFrame: 0x80 | (7 << 4) | 1,
        systemSongPosition: 0x80 | (7 << 4) | 2,
        systemSongSelect: 0x80 | (7 << 4) | 3,
        systemTuneRequest: 0x80 | (7 << 4) | 6,
        systemExclusiveEnd: 0x80 | (7 << 4) | 7,
        systemClock: 0x80 | (7 << 4) | 8,
        systemStart: 0x80 | (7 << 4) | 10,
        systemContinue: 0x80 | (7 << 4) | 11,
        systemStop: 0x80 | (7 << 4) | 12,
        systemActiveSensing: 0x80 | (7 << 4) | 14,
        systemReset: 0x80 | (7 << 4) | 15,

        getType: function(status) {
          // Remove channel number.
          if ((status & 0xf0) != MIDI.Status.system)
            return status & 0xf0;

          // Return 'system' message type.
          return status;
        },

        getChannel: function(status) {
          return status & 0x0f;
        }
      }),

      system: null,
      sequence: 0,
      deviceInput: null,
      deviceOutput: null,
      timeout: null,

      printPort: function(port) {
        Log.print('Port ' + port.id + ' (<b>' + port.name + '</b>): State=' + port.state);
      },

      // Print available MIDI ports. Their names might be different on different
      // operating systems.
      printStatus: function() {
        if (!MIDI.system)
          return;

        MIDI.system.inputs.forEach((port, key) => {
          MIDI.printPort(port);
        });

        MIDI.system.outputs.forEach((port, key) => {
          MIDI.printPort(port);
        });

        if (MIDI.deviceInput)
          Log.printDevice(MIDI.deviceInput, 'Device selected');
      },

      // Find the output port with the same name at the same index.
      findOutputPort: function(input) {
        // Count the input ports with our name and return our index.
        function inputPortIndex(input) {
          let idx = 0;
          const inputs = MIDI.system.inputs.values();
          for (let port = inputs.next(); port && !port.done; port = inputs.next()) {
            if (port.value.name != input.name)
              continue;

            if (port.value == input)
              return idx;

            idx++;
          }
        }

        const input_idx = inputPortIndex(input);
        let output_idx = 0;
        const outputs = MIDI.system.outputs.values();
        for (let port = outputs.next(); port && !port.done; port = outputs.next()) {
          let name = port.value.name;

          // Windows names the ports *MIDIIN* and *MIDIOUT*.
          if (input.name.match(/^MIDIIN[1-9]/))
            name = name.replace(/^MIDIOUT/, 'MIDIIN');

          if (name != input.name)
            continue;

          if (output_idx == input_idx) {
            if (output_idx > 0)
              Log.print('Multiple devices with the same name. Matching <b>' + input.id + '</b> with <b>' + port.value.id + '</b>');
            return port.value;
          }

          output_idx++;
        }

        if (input_idx > 0)
          Log.print('Multiple devices with the same name <b>' + input.name + '</b>. Please try to connect only one device of the same type.');
      },

      // Disconnect the current device.
      disconnectDevice: function() {
        if (!this.deviceInput)
          return;

        Log.printDevice(MIDI.deviceInput, 'Device deselected');

        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        this.deviceInput.onmidimessage = null;
        this.deviceInput.close();
        this.deviceInput = null;
        this.deviceOutput.close();
        this.deviceOutput = null;

        Device.disconnect();
      },

      // Connect or switch to a device. We always need the matching pair of
      // 'input' and 'output' device. The operating systems and WebMIDI does
      // not provide a reliable way to connect the both, so try to figure it
      // out by their port names and position/index in the device lists.
      connectDevice: function(id) {
        // Incoming MIDI messages.
        function onMIDIMessage(message) {
          if (message.currentTarget != MIDI.deviceInput) {
            Log.printDevice(message.currentTarget, 'Not connected, ignoring incoming message');
            return;
          }

          // Incoming SysEx messages.
          function handleSystemExclusive(message) {
            const json = new TextDecoder().decode(message);
            let data;

            try {
              data = JSON.parse(json);

            } catch (error) {
              Log.printDevice(MIDI.deviceInput, 'Received unknown message format');
              return;
            }

            if (!data['com.versioduo.device']) {
              Log.printDevice(MIDI.deviceInput, 'Received data for unknown interface');
              return;
            }

            if (MIDI.timeout) {
              clearTimeout(MIDI.timeout);
              MIDI.timeout = null;
            }

            Device.handleReply(data['com.versioduo.device']);
          }

          const type = MIDI.Status.getType(message.data[0]);
          const channel = MIDI.Status.getChannel(message.data[0]);

          switch (type) {
            case MIDI.Status.noteOn: {
              const note = message.data[1];
              const velocity = message.data[2];
              if (velocity > 0)
                Log.printDevice(message.target, 'Received <b>NoteOn</b> <i>' +
                  MIDI.Note.name(note) + '(' + note + ')</i> with velocity ' + velocity + ' on channel <i>#' + (channel + 1)) + '</i>';

              else
                Log.printDevice(message.target, 'Received <b>NoteOff</b> <i>' +
                  MIDI.Note.name(note) + '(' + note + ')</i> on channel #' + (channel + 1));

              Output.updateNote(channel, note, velocity);
              break;
            }

            case MIDI.Status.noteOff: {
              const note = message.data[1];
              const velocity = message.data[2];
              Log.printDevice(message.target, 'Received <b>NoteOff</b> <i>' +
                MIDI.Note.name(note) + '(' + note + ')</i> with velocity ' + velocity + ' on channel #' + (channel + 1));

              Output.updateNote(channel, note, 0);
              break;
            }

            case MIDI.Status.aftertouch: {
              const note = message.data[1];
              const pressure = message.data[2];
              Log.printDevice(message.target, 'Received <b>Aftertouch</b> for note <i>' + MIDI.Note.name(note) + '(' + note + ')</i>' + ' with pressure <i>' + pressure + '</i> on channel <i>#' + (channel + 1) + '</i>');

              Output.updateNoteAftertouch(channel, note, pressure);
              break;
            }

            case MIDI.Status.controlChange: {
              const controller = message.data[1];
              const value = message.data[2];
              Log.printDevice(message.target, 'Received <b>ControlChange</b> <i>' + controller +
                '</i> with value <i>' + value + '</i> on channel <i>#' + (channel + 1) + '</i>');

              Output.updateController(channel, controller, value);
              break;
            }

            case MIDI.Status.aftertouchChannel: {
              const value = message.data[1];
              Log.printDevice(message.target, 'Received <b>Aftertouch Channel</b> with value <i>' + value + '</i> on channel <i>#' + (channel + 1) + '</i>');
              break;
            }

            case MIDI.Status.systemExclusive: {
              Log.printDevice(message.target, 'Received <b>SystemExclusive</b> length=' + message.data.length);

              // 0x7d == MIDI private/research ID.
              if (message.data[2] != 0x7d)
                handleSystemExclusive(message.data.slice(2, -1));
              break;
            }
          }
        }

        this.disconnectDevice();

        const input = this.system.inputs.get(id);
        if (!input) {
          Log.printDevice(input, 'Unable to find input port <b>' + id + '</b>');
          return;
        }

        // Find the corresponding output port.
        const output = this.findOutputPort(input);
        if (!output) {
          Log.printDevice(input, 'Unable to find output port for <b>' + input.id + '</b>');
          return;
        }

        // Give this connection attempt a sequence number, so we can 'cancel'
        // the promise which might be resolved later, when a new connection
        // attempt is already submitted from the user interface.
        this.sequence++;
        let sequence = this.sequence;

        // Try to open the input device.
        input.open().then(() => {
          if (sequence != this.sequence)
            return;

          // We got the input, try to open the corresponding output device.
          output.open().then(() => {
            if (sequence != this.sequence)
              return;

            // We have input and output.
            this.deviceInput = input;
            this.deviceOutput = output;

            // Dispatch incoming messages.
            this.deviceInput.onmidimessage = onMIDIMessage;

            // Request information from device.
            Device.sendRequest();
          });
        });

        function handler() {
          MIDI.timeout = null;
          Log.print('Unable to connect to device <b>' + input.name + '</b>');
          MIDI.disconnectDevice();
        }
        this.timeout = setTimeout(handler, 1000);

        Device.select.isLoading.classList.add('is-loading');
      },

      // Connect to the MIDI subsystem.
      setup: function() {
        if (navigator.requestMIDIAccess) {
          navigator.requestMIDIAccess({
            sysex: true,
            software: false

          }).then(onMIDISuccess, function() {
            Log.print('Unable to access MIDI devices');
            Device.banner.error('Unable to access MIDI devices');
            return;
          });

        } else {
          Log.print('This browser does not support WebMIDI');
          Device.banner.error('This browser does not support WebMIDI.');
          return;
        }

        function onMIDISuccess(access) {
          Log.print('WebMIDI initialized');
          MIDI.system = access;

          // Subscribe to device connect/disconnect events.
          MIDI.system.onstatechange = onStateChange;

          MIDI.printStatus();
          Device.updateList();
        }

        // Device connect/disconnect events.
        function onStateChange(event) {
          MIDI.printPort(event.port);

          // Disconnect if the current device is unplugged.
          if (MIDI.deviceInput == event.port && event.port.state == 'disconnected')
            MIDI.disconnectDevice();

          Device.updateList();
        }
      },

      // Outgoing messages.
      sendNoteOn: function(channel, note, velocity) {
        Log.printDevice(this.deviceOutput, 'Sending <b>NoteOn</b> <i>#' + note +
          '</i> with velocity <i>' + velocity + '</i> on channel <i>#' + (channel + 1) + '</i>');
        MIDI.deviceOutput.send([MIDI.Status.noteOn | channel, note, velocity]);
      },

      sendNoteOff: function(channel, note, velocity) {
        if (velocity == null)
          velocity = 64;
        Log.printDevice(this.deviceOutput, 'Sending <b>NoteOff</b> <i>#' + note +
          '</i> with velocity <i>' + velocity + '</i> on channel <i>#' + (channel + 1) + '</i>');
        MIDI.deviceOutput.send([MIDI.Status.noteOff | channel, note, velocity]);
      },

      sendControlChange: function(channel, controller, value) {
        Log.printDevice(this.deviceOutput, 'Sending <b>Control Change</b> <i>#' + controller +
          '</i> with value <i>' + value + '</i> on channel <i>#' + (channel + 1) + '</i>');
        MIDI.deviceOutput.send([MIDI.Status.controlChange | channel, controller, value]);
      },

      sendProgramChange: function(channel, value) {
        Log.printDevice(this.deviceOutput, 'Sending <b>Program Change</b> <i>#' + (value + 1) +
          '</i> on channel <i>#' + (channel + 1) + '</i>');
        MIDI.deviceOutput.send([MIDI.Status.programChange | channel, value]);
      },

      sendAftertouchChannel: function(channel, value) {
        Log.printDevice(this.deviceOutput, 'Sending <b>Aftertouch Channel</b> <i>#' + value +
          '</i> on channel <i>#' + (channel + 1) + '</i>');
        MIDI.deviceOutput.send([MIDI.Status.aftertouchChannel | channel, value]);
      },

      sendPitchBend: function(channel, value) {
        const bits = value + 8192;
        const msb = (bits >> 7) & 0x7f;
        const lsb = bits & 0x7f;
        Log.printDevice(this.deviceOutput, 'Sending <b>Pitch Bend</b> <i>#' + value +
          '</i> on channel <i>#' + (channel + 1) + '</i>');
        MIDI.deviceOutput.send([MIDI.Status.pitchBend | channel, lsb, msb]);
      },

      sendSystemReset: function(message) {
        Log.printDevice(this.deviceOutput, 'Sending <b>SystemReset</b>');
        this.deviceOutput.send([MIDI.Status.systemReset]);
      },

      sendSystemExclusive: function(message) {
        // 0x7d == MIDI private/research ID.
        const sysex = [MIDI.Status.systemExclusive, 0x7d];

        // Escape unicode characters to fit into a 7 bit byte stream.
        const json = JSON.stringify(message).replace(/[\u007f-\uffff]/g,
          function(c) {
            return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
          }
        );

        for (let i = 0; i < json.length; i++)
          sysex.push(json.charCodeAt(i));

        sysex.push(MIDI.Status.systemExclusiveEnd);

        Log.printDevice(this.deviceOutput, 'Sending <b>SystemExclusive</b> length=' + sysex.length);
        this.deviceOutput.send(sysex);
      }
    })

    // Inline element to show a notification.
    class Notify {
      constructor(element) {
        this.element = element;

        this.element.style.display = 'none';
        this.element.classList.add('notification');
        this.element.classList.add('is-light');

        const button = document.createElement('button');
        button.classList.add('delete');
        button.addEventListener('click', () => {
          this.clear();
        });
        this.element.appendChild(button);

        this.text = document.createElement('div');
        this.element.appendChild(this.text);
      }

      clear(text) {
        this.element.style.display = 'none';
        this.element.classList.remove('is-info');
        this.element.classList.remove('is-success');
        this.element.classList.remove('is-warning');
        this.element.classList.remove('is-danger');
        this.text.innerHTML = '';
      }

      info(text) {
        this.clear();
        this.element.classList.add('is-info');
        this.element.style.display = '';
        this.text.innerHTML = text;
      }

      success(text) {
        this.clear();
        this.element.classList.add('is-success');
        this.element.style.display = '';
        this.text.innerHTML = text;
      }

      warn(text) {
        this.clear();
        this.element.classList.add('is-warning');
        this.element.style.display = '';
        this.text.innerHTML = text;
      }

      error(text) {
        this.clear();
        this.element.classList.add('is-danger');
        this.element.style.display = '';
        this.text.innerHTML = text;
      }
    }
  </script>

  <!-- Device selector and metadata table -->
  <section class="section">
    <span class="offset"></span>
    <div class="container">
      <div id="banner"></div>
      <h2 class="title">
        Device
      </h2>
      <p class="subtitle">
        Connection and Information
      </p>
      <div class="field has-addons">
        <div id="deviceSelectIsLoading" class="select">
          <select id="deviceSelect" title="Select the MIDI device to connect to" disabled onchange="Device.connect();">
            <option value="">Connect to ...</option>
          </select>
        </div>
        <button class="button" title="Reload the page" onclick="location.reload(true);"><i class="fas fa-redo"></i></button>
      </div>
      <div class="tabs is-medium is-boxed is-toggle is-fullwidth">
        <ul>
          <li id="deviceTabInfo" onclick="Device.switchTab('info');">
            <a>Info</a>
          </li>
          <li id="deviceTabDetails" onclick="Device.switchTab('details');">
            <a>Details</a>
          </li>
          <li id="deviceTabUpdate" onclick="Device.switchTab('update');">
            <a>Update</a>
          </li>
        </ul>
      </div>
      <div id="deviceInfo" class="table-container" style="display:none">
        <table class="table is-fullwidth is-striped is-narrow">
          <tbody id="deviceInfoList">
          </tbody>
        </table>
      </div>
      <div id="deviceDetails" class="table-container" style="display:none">
        <div class="field has-addons">
          <button class="button is-primary" title="Refresh data" onclick="Device.sendRequest();">Refresh</button>
        </div>
        <table class="table is-fullwidth is-striped is-narrow">
          <tbody id="deviceDetailsList">
          </tbody>
        </table>
      </div>
      <div id="deviceUpdate" class="content" style="display:none">
        <div class="field has-addons">
          <button id="deviceUpdatePorts" class="button" title="Enable ports to access children devices" disabled onclick="Device.rebootWithPorts();">Enable Ports</button>
          <button class="button" title="Load a firmware image" onclick="Device.loadFirmware();">Load</button>
          <button id="deviceUpdateUpload" class="button is-primary" title="Update the device with the new firmware" disabled onclick="Device.uploadFirmware()">Upload</button>
        </div>
        <progress id="deviceUpdateProgress" class="progress is-small" value="0" style="display:none"></progress>
        <div id="deviceUpdateNotify"></div>
        <p class="subtitle">
          Firmware
        </p>
        <div class="table-container">
          <table class="table is-fullwidth is-striped is-narrow">
            <tbody id="deviceUpdateCurrentList">
            </tbody>
          </table>
        </div>
        <div id="deviceUpdateFirmware" style="display:none">
          <p class="subtitle">
            Firmware Update
          </p>
          <div class="table-container">
            <table class="table is-fullwidth is-striped is-narrow">
              <tbody id="deviceUpdateFirmwareList">
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <h3 class="title">
        Settings
      </h3>
      <div class="field has-addons">
        <button class="button isEnabled" title="Reboot the device" disabled onclick="Device.reboot();">Reboot</button>
        <button class="button isEnabled" title="Reset the device" disabled onclick="Device.reset();">Reset</button>
        <button class="button isEnabled" title="Silence all active notes (CC #123)" disabled onclick="MIDI.sendControlChange(Input.channel, MIDI.CC.allNotesOff, 0);">Notes Off</button>
        <button class="button isEnabled is-primary" title="Store the settings in the device" disabled onclick="Device.sendConfig();">Save</button>
      </div>
      <div id="deviceNotify"></div>
      <div class="field has-addons">
        <button class="button button-field has-background-grey-lighter inactive" tabindex="-1">Name</button>
        <input id="deviceName" class="input input-text isEnabled" title="The USB device name" type="text" maxlength="31" disabled>
      </div>
      <div id="devicePorts" class="field has-addons" style="display:none">
        <button class="button button-field has-background-grey-lighter inactive" tabindex="-1">Ports</button>
        <input id="devicePortsValue" class="input input-number isEnabled" title="The number of MIDI ports" type="number" min="1" max="16" disabled>
      </div>
    </div>
  </section>
  <script>
    'use strict';

    // Drop-down menu to connect to a device. The list is updated when devices
    // are connected/disconnected from the system.
    const Device = Object.seal({
      banner: new Notify(document.getElementById('banner')),
      select: {
        element: document.getElementById('deviceSelect'),
        isLoading: document.getElementById('deviceSelectIsLoading')
      },
      tab: 'info',
      info: {
        element: document.getElementById('deviceInfo'),
        elementTab: document.getElementById('deviceTabInfo'),
        elementList: document.getElementById('deviceInfoList'),
        metadata: null,
        system: null
      },
      details: {
        element: document.getElementById('deviceDetails'),
        elementTab: document.getElementById('deviceTabDetails'),
        elementList: document.getElementById('deviceDetailsList')
      },
      update: {
        element: document.getElementById('deviceUpdate'),
        elementTab: document.getElementById('deviceTabUpdate'),
        elementCurrentList: document.getElementById('deviceUpdateCurrentList'),
        elementFirmware: document.getElementById('deviceUpdateFirmware'),
        elementFirmwareList: document.getElementById('deviceUpdateFirmwareList'),
        elementPorts: document.getElementById('deviceUpdatePorts'),
        elementUpload: document.getElementById('deviceUpdateUpload'),
        elementProgress: document.getElementById('deviceUpdateProgress'),
        notify: new Notify(document.getElementById('deviceUpdateNotify')),
        firmware: {
          bytes: null,
          hash: null,
          current: null
        }
      },
      notify: new Notify(document.getElementById('deviceNotify')),
      timeout: null,
      name: {
        element: document.getElementById('deviceName'),
      },
      ports: {
        element: document.getElementById('devicePorts'),
        elementValue: document.getElementById('devicePortsValue'),
      },

      switchTab: function(tab) {
        this.info.elementTab.classList.remove('is-active');
        this.details.elementTab.classList.remove('is-active');
        this.update.elementTab.classList.remove('is-active');
        this.info.element.style.display = 'none';
        this.details.element.style.display = 'none';
        this.update.element.style.display = 'none';

        if (!MIDI.deviceInput)
          return;

        switch (tab) {
          case 'info':
            this.info.elementTab.classList.add('is-active');
            this.info.element.style.display = '';
            this.tab = tab;
            break;

          case 'details':
            this.details.elementTab.classList.add('is-active');
            this.details.element.style.display = '';
            this.tab = tab;
            break;

          case 'update':
            this.update.elementTab.classList.add('is-active');
            this.update.element.style.display = '';
            this.loadFirmwareIndex();
            this.tab = tab;
            break;
        }
      },

      // Dim UI elements when no device is connected, or an action waits for a reply.
      setEnabled: function(enabled) {
        const isEnabled = Array.prototype.slice.call(document.querySelectorAll('.isEnabled'), 0);
        isEnabled.forEach((el) => {
          el.disabled = !enabled;
        });
      },

      setConnected: function(connected) {
        if (connected)
          this.select.element.options[0].text = 'Disconnect ...';
        else
          this.select.element.options[0].text = 'Connect to ...';

        this.select.isLoading.classList.remove('is-loading');
        this.updateList();
        this.setEnabled(connected)
      },

      updateList: function() {
        this.select.element.options.length = 1;
        let previous = '';
        let number = 2;

        // Iterate over the input ports, only add the device to the list if we
        // find an output port with the same name and index.
        MIDI.system.inputs.forEach((port, key) => {
          if (MIDI.findOutputPort(port)) {
            const option = document.createElement('option');
            option.value = port.id;

            let name = port.name;
            if (name == previous)
              name += ' #' + number++;
            else
              number = 2;
            previous = port.name;

            option.text = name;
            if (port == MIDI.deviceInput)
              option.selected = true
            Device.select.element.add(option);
          }
        });

        const disable = this.select.element.options.length == 1;
        const isDisabled = this.select.element.disabled;
        this.select.element.disabled = disable;

        // If we enable the previously disabled selector, select it.
        if (!disable && isDisabled)
          this.select.element.focus();
      },

      sendRequest: function() {
        Log.printDevice(MIDI.deviceOutput, 'Calling <b>getAll()</>');
        MIDI.sendSystemExclusive({
          'com.versioduo.device': {
            'method': 'getAll'
          }
        });

        Log.printDevice(MIDI.deviceInput, 'Waiting for reply ...');
      },

      // Process the reply with a com.versioduo.device message.
      handleReply: function(data) {
        Log.printDevice(MIDI.deviceInput, 'Received <b>com.versioduo.device<b> message');

        if (data.firmware && data.firmware.status) {
          Device.uploadFirmwareBlock(data.firmware.status);
          return;
        }

        if (!data.metadata) {
          Log.printDevice(MIDI.deviceInput, 'Missing device information');
          MIDI.disconnectDevice();
          return;
        }

        Device.setConnected(true);
        Device.show(data.metadata, data.system);
        Output.show(data.output);
        Configuration.show(data.configuration);
      },

      disconnect: function() {
        this.tab = 'info';
        this.clear();
        this.setConnected(false);

        Input.disconnect();
        Output.disconnect();
        Configuration.clear();

        window.scroll(0, 0);
        this.select.element.focus();
      },

      // Triggered by the main drop-down menu.
      connect: function() {
        if (this.select.element.selectedIndex == 0)
          MIDI.disconnectDevice();

        else
          MIDI.connectDevice(this.select.element.value);
      },

      sendConfig: function() {
        Log.printDevice(MIDI.deviceOutput, 'Calling <b>writeConfiguration()</b> ');
        MIDI.sendSystemExclusive({
          'com.versioduo.device': {
            'method': 'writeConfiguration',
            'configuration': {
              'name': this.name.element.value,
              'ports': Number(this.ports.elementValue.value)
            }
          }
        });

        Device.setEnabled(false);

        function handler() {
          Device.timeout = null;
          Device.notify.error('No reply from device. Changes might not be not saved.');
          Log.printDevice(MIDI.deviceInput, 'No reply from device');
          Device.setEnabled(true);
        }
        this.timeout = setTimeout(handler, 1000);
      },

      // A table showing the queried metadata from the device.
      show: function(meta, system) {
        const notify = this.timeout != null;
        this.clear();
        if (notify)
          this.notify.success('Configuration updated.');

        this.info.metadata = meta;
        this.info.system = system;

        // The info tab.
        Object.keys(meta).forEach((key) => {
          const name = key.charAt(0).toUpperCase() + key.slice(1);
          const value = meta[key];

          const tr = document.createElement('tr');
          const tdName = document.createElement('td');
          tdName.innerHTML = name;
          tr.appendChild(tdName);

          const tdValue = document.createElement('td');
          if (typeof value == 'string' && value.match(/^https?:\/\//)) {
            const a = document.createElement('a');
            a.setAttribute('href', value);
            a.setAttribute('target', 'home');
            a.innerHTML = value.replace(/^https?:\/\//, '');
            tdValue.appendChild(a);

          } else
            tdValue.innerHTML = value;

          tr.appendChild(tdValue);
          this.info.elementList.appendChild(tr);
        });

        // The details tab.
        function printObject(parent, object) {
          Object.keys(object).forEach((key) => {
            let name = key;
            if (parent)
              name = parent + '.' + name;

            const value = object[key];
            if (typeof value == 'object') {
              printObject(name, value);

            } else {
              const tr = document.createElement('tr');

              const tdName = document.createElement('td');
              tdName.innerHTML = name;
              tr.appendChild(tdName);

              const tdValue = document.createElement('td');
              tdValue.innerHTML = value;
              tr.appendChild(tdValue);

              Device.details.elementList.appendChild(tr);
            }
          });
        }
        printObject(null, system);

        // The update tab.
        let tr = document.createElement('tr');
        let td = document.createElement('td');
        td.innerHTML = 'Version';
        tr.appendChild(td);
        td = document.createElement('td');
        td.innerHTML = this.info.metadata.version;
        tr.appendChild(td);
        this.update.elementCurrentList.appendChild(tr);

        tr = document.createElement('tr');
        td = document.createElement('td');
        td.innerHTML = 'Id';
        tr.appendChild(td);
        td = document.createElement('td');
        td.innerHTML = this.info.system.firmware.id;
        tr.appendChild(td);
        this.update.elementCurrentList.appendChild(tr);

        tr = document.createElement('tr');
        td = document.createElement('td');
        td.innerHTML = 'Board';
        tr.appendChild(td);
        td = document.createElement('td');
        td.innerHTML = this.info.system.firmware.board;
        tr.appendChild(td);
        Device.update.elementCurrentList.appendChild(tr);

        tr = document.createElement('tr');
        td = document.createElement('td');
        td.innerHTML = 'Hash';
        tr.appendChild(td);
        td = document.createElement('td');
        td.innerHTML = this.info.system.firmware.hash;
        tr.appendChild(td);
        this.update.elementCurrentList.appendChild(tr);

        this.switchTab(this.tab);

        // The device name.
        if (system.name)
          this.name.element.value = system.name;
        this.name.element.placeholder = this.info.metadata.product;

        // The number of MIDI ports.
        if (system.ports && system.ports.announce > 0) {
          Device.update.elementPorts.disabled = false;
          this.ports.elementValue.value = system.ports.configured;
          this.ports.element.style.display = '';
        }
      },

      clear: function() {
        this.select.isLoading.classList.remove('is-loading');

        this.switchTab();
        this.info.metadata = null;
        this.info.system = null;

        while (this.info.elementList.firstChild)
          this.info.elementList.firstChild.remove();

        while (this.details.elementList.firstChild)
          this.details.elementList.firstChild.remove();

        while (this.update.elementCurrentList.firstChild)
          this.update.elementCurrentList.firstChild.remove();

        this.clearFirmware();

        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        this.notify.clear();

        this.name.element.value = '';
        this.name.element.placeholder = '';

        this.ports.element.style.display = 'none';
        this.ports.elementValue.value = 1;
      },

      reset: function() {
        MIDI.sendSystemReset();
        this.sendRequest();
      },

      reboot: function() {
        Log.printDevice(MIDI.deviceInput, 'Calling <b>reboot()</>');
        MIDI.sendSystemExclusive({
          'com.versioduo.device': {
            'method': 'reboot'
          }
        });

        MIDI.disconnectDevice();
      },

      // Reboot the device and temporarily create MIDI ports/virtual
      // cables to access children devices. The device can describe itself
      // how many children devices are expected to be connected.
      rebootWithPorts: function() {
        let ports = this.info.system.ports.announce;

        // Ports enabled but no custom number of ports specified, use the maximum.
        if (ports == 1)
          ports = 16;

        Log.printDevice(MIDI.deviceInput, 'Calling <b>reboot()</>');
        MIDI.sendSystemExclusive({
          'com.versioduo.device': {
            'method': 'reboot',
            'reboot': {
              'ports': ports
            }
          }
        });

        MIDI.disconnectDevice();
      },

      clearFirmware: function() {
        this.update.notify.clear();

        this.update.elementPorts.disabled = true;
        this.update.elementUpload.disabled = true;

        this.update.elementProgress.style.display = 'none';
        this.update.elementProgress.value = 0;

        this.update.elementFirmware.style.display = 'none';
        while (this.update.elementFirmwareList.firstChild)
          this.update.elementFirmwareList.firstChild.remove();

        this.update.firmware.bytes = null;
        this.update.firmware.hash = null;
      },

      // Load 'index.json' and from the 'download' URL and check if there is a firmware update available.
      loadFirmwareIndex: function() {
        if (!this.info.system || !this.info.system.firmware.download)
          return;

        if (Device.update.firmware.bytes)
          return;

        Log.printDevice(MIDI.deviceInput, 'Downloading firmware update index: <b>' + this.info.system.firmware.download + '/index.json</b>');
        const request = new XMLHttpRequest();
        request.onreadystatechange = () => {
          let index;

          if (request.readyState == 4 && request.status == 200) {
            try {
              index = JSON.parse(request.responseText);

            } catch (error) {
              Log.printDevice(MIDI.deviceInput, 'Unable to parse firmware update index: <b>' + this.info.system.firmware.download + '/index.json</b>');
              return;
            }

            Log.printDevice(MIDI.deviceInput, 'Retrieved firmware update index');

            const update = index[this.info.system.firmware.id];
            if (!update) {
              Log.printDevice(MIDI.deviceInput, 'No firmware update found for this device.');
              return;
            }

            if (this.info.system.board != update.board) {
              Log.printDevice(MIDI.deviceInput, 'No firmware update found for this board.');
              return;
            }

            if (this.info.system.firmware.hash == update.hash) {
              this.update.notify.success('The firmware is up-to-date.');
              return;
            }

            if (this.info.system.firmware.version > update.version) {
              this.update.notify.warn('A more recent firmware is already installed.');
              return;
            }

            Log.printDevice(MIDI.deviceInput, 'Downloading firmware update: <b>' + update.file + '</b>');
            const firmware = new XMLHttpRequest();
            firmware.onreadystatechange = () => {
              if (firmware.readyState == 4) { // DONE
                if (firmware.status == 200) {
                  const bytes = firmware.response;
                  Log.printDevice(MIDI.deviceInput, 'Retrieved firmware image, length=' + bytes.byteLength);
                  this.showFirmware(new Uint8Array(bytes));

                } else
                  Log.printDevice(MIDI.deviceInput, 'Failed to download firmware image: ' + firmware.status);
              }
            }

            firmware.open("GET", this.info.system.firmware.download + '/' + update.file, true);
            firmware.responseType = "arraybuffer";
            firmware.send();
          }
        };

        request.open("GET", this.info.system.firmware.download + '/index.json', true);
        request.send();
      },

      // Load a firmware image from the local disk.
      loadFirmware: function() {
        this.clearFirmware();

        // Temporarily create a hidden 'browse button' and trigger a file upload.
        const input = document.createElement('input');
        input.setAttribute('type', 'file');
        input.setAttribute('accept', '.bin');
        input.style.display = 'none';
        document.body.appendChild(input);

        input.addEventListener('change', () => {
          const reader = new FileReader();
          reader.onload = (element) => {
            this.showFirmware(new Uint8Array(reader.result));
          }

          reader.readAsArrayBuffer(input.files[0]);
          input.remove();
        });

        input.click();
      },

      // Present a new firmware image to update the current one.
      showFirmware: function(bytes) {
        // Read the metadata in the image; the very end of the image contains
        // the the JSON metadata record with a leading and trailing NUL character.
        let metaStart = bytes.length - 2;
        while (bytes[metaStart] != 0) {
          metaStart--;
          if (metaStart < 4) {
            this.update.notify.warn('Unknown file type. No valid device metadata found.');
            return;
          }
        }

        const metaBytes = bytes.slice(metaStart + 1, bytes.length - 1);
        const metaString = new TextDecoder().decode(metaBytes);

        let meta;
        try {
          meta = JSON.parse(metaString);

        } catch (error) {
          this.update.notify.warn('Unknown file type. Unable to parse metadata.');
          return;
        }

        if (meta.interface != "com.versioduo.firmware") {
          this.update.notify.warn('Unknown file type. Missing metadata.');
          return;
        }

        // We found metadata in the loaded image.
        Device.update.firmware.bytes = bytes;

        let tr = document.createElement('tr');
        let td = document.createElement('td');
        td.innerHTML = 'Version';
        tr.appendChild(td);
        td = document.createElement('td');
        td.innerHTML = meta.version;
        tr.appendChild(td);
        Device.update.elementFirmwareList.appendChild(tr);

        tr = document.createElement('tr');
        td = document.createElement('td');
        td.innerHTML = 'Id';
        tr.appendChild(td);
        td = document.createElement('td');
        td.innerHTML = meta.id;
        tr.appendChild(td);
        Device.update.elementFirmwareList.appendChild(tr);

        tr = document.createElement('tr');
        td = document.createElement('td');
        td.innerHTML = 'Board';
        tr.appendChild(td);
        td = document.createElement('td');
        td.innerHTML = meta.board;
        tr.appendChild(td);
        Device.update.elementFirmwareList.appendChild(tr);

        tr = document.createElement('tr');
        td = document.createElement('td');
        td.innerHTML = 'Hash';
        tr.appendChild(td);
        const tdHash = document.createElement('td');
        tr.appendChild(tdHash);
        Device.update.elementFirmwareList.appendChild(tr);

        crypto.subtle.digest('SHA-1', Device.update.firmware.bytes).then((hash) => {
          const array = Array.from(new Uint8Array(hash));
          const hex = array.map(b => b.toString(16).padStart(2, '0')).join('');
          Device.update.firmware.hash = hex;
          tdHash.innerHTML = hex;

          if (Device.info.system.board && meta.board != Device.info.system.board)
            Device.update.notify.error('The firmware update is for a different board which has the name <b>' + meta.board + '</>.');

          else if (meta.id != Device.info.system.firmware.id)
            Device.update.notify.warn('The firmware update appears to provide a different functionality, it has the name <b>' + meta.id + '</>.');

          else if (meta.version < Device.info.metadata.version)
            Device.update.notify.warn('The firmware update is version <b>' + meta.version + '</b>, which is older than the current firmware.');

          else if (Device.update.firmware.hash == Device.info.system.firmware.hash)
            Device.update.notify.success('The firmware is up-to-date.');

          else
            Device.update.notify.warn('Press <b>Upload</b> to install version <b>' + meta.version + '</b> of the firmware.');

          Device.update.elementUpload.disabled = false;
          Device.update.elementFirmware.style.display = '';
        });
      },

      // Transfer the loded image to the device.
      uploadFirmware: function() {
        this.update.elementProgress.value = 0;
        this.update.elementProgress.max = this.update.firmware.bytes.length;
        this.update.elementProgress.style.display = '';

        // Send the first block; the reply messages will trigger the remaining blocks.
        this.update.firmware.current = 0;
        this.uploadFirmwareBlock();
      },

      // Send one block of our firmware image. This will be called from
      // the incoming message handler, when the previous block was sucessfully written.
      uploadFirmwareBlock: function(status) {
        if (status) {
          switch (status) {
            case 'success':
              break;

            case 'hashMismatch':
              Device.update.notify.error('Error while verifying the transferred firmware.');
              return;

            case 'invalidOffset':
              Device.update.notify.error('Invalid parameters for firmware update.');
              return;

            default:
              Device.update.notify.error('Error while updating the firmware: ' + status);
              return;
          }
        }

        // The last update packet was successful. If the device is connected
        // over USB we will notice the automatic reboot, we will not detect the reboot
        // of a children device, so disconnect it here.
        if (this.update.firmware.current == null) {
          Log.printDevice(MIDI.deviceOutput, 'Firmware update successful. Disconnecting device');
          MIDI.disconnectDevice();
          return;
        }

        const offset = this.update.firmware.current;
        // The block size is fixed to 8k. Daisy-chained devices might not be able to forward larger packets.
        const block = this.update.firmware.bytes.slice(offset, offset + 0x2000);
        const data = btoa(String.fromCharCode.apply(null, block));
        let request = {
          'method': 'writeFirmware',
          'firmware': {
            'offset': offset,
            'data': data
          }
        };

        if (this.update.firmware.current + 0x2000 <= this.update.firmware.bytes.length) {
          // Prepare for next block.
          this.update.elementProgress.value = offset;
          this.update.firmware.current += 0x2000;

        } else {
          // Last block.
          this.update.elementProgress.value = this.update.firmware.bytes.length;
          this.update.firmware.current = null;

          // Add our hash to the request; if the device has received
          // the correct image it copies it over and reboots.
          Log.printDevice(MIDI.deviceOutput, 'Firmware submitted. Requesting device update with hash <b>' + this.update.firmware.hash + '</b>');
          request.firmware.hash = this.update.firmware.hash;
        }

        MIDI.sendSystemExclusive({
          'com.versioduo.device': request
        });
      }
    })
  </script>



  <!-- MIDI In, play notes -->
  <section class="section">
    <span id="input" class="offset"></span>
    <div class="container">
      <h2 class="title">
        MIDI In
      </h2>
      <p class="subtitle">
        Play notes and adjust controllers
      </p>
      <div id="inputControls"></div>
      <div id="inputControllers" class="subsection" style="display:none">
        <h3 class="title">
          Controllers
        </h3>
        <div id="inputControllersList"></div>
      </div>
      <div id="inputNotes" class="subsection" style="display:none">
        <h3 class="title">
          Notes
        </h3>
        <div id="inputNotesControls"></div>
        <div id="inputNotesList"></div>
        <div id="inputNotesChromatic"></div>
      </div>
      <div id="inputCalibration" class="subsection" style="display:none">
        <h3 class="title">
          Calibration
        </h3>
        <div class="field has-addons">
          <button class="button" title="Play all notes with velocity 1" onclick="Input.playAll();">Play Min</button>
          <button class="button isEnabled is-primary" title="Store the calibration in the device" onclick="Input.sendCalibration();">Save</button>
        </div>
        <div id="inputCalibrationNotify"></div>
        <div id="inputCalibrationNotes"></div>
      </div>
    </div>
  </section>


  <script>
    'use strict';

    const Input = Object.seal({
      channel: 0,
      controls: {
        element: document.getElementById('inputControls'),
        program: null
      },
      controllers: {
        element: document.getElementById('inputControllers'),
        elementList: document.getElementById('inputControllersList')
      },
      notes: {
        element: document.getElementById('inputNotes'),
        controls: {
          element: document.getElementById('inputNotesControls'),
          velocity: 15
        },
        elementList: document.getElementById('inputNotesList'),
        chromatic: {
          element: document.getElementById('inputNotesChromatic'),
          start: 0,
          count: 0,
          playAllIndex: 0
        },
        calibration: {
          element: document.getElementById('inputCalibration'),
          notify: new Notify(document.getElementById('inputCalibrationNotify')),
          timeout: null,
          elementNotes: document.getElementById('inputCalibrationNotes'),
          program: null,
          values: null
        }
      },

      show: function(data, calibrationData) {
        function addController(name, controller, value, valueFine) {
          const field = document.createElement('div');
          field.classList.add('field');
          field.classList.add('has-addons');

          const button = document.createElement('button');
          button.classList.add('button');
          button.classList.add('button-field');
          button.classList.add('has-background-grey-lighter');
          button.classList.add('inactive');
          button.innerHTML = 'CC #' + controller;
          button.tabIndex = -1;
          field.appendChild(button);

          const button2 = document.createElement('button');
          button2.classList.add('button');
          button2.classList.add('button-text');
          button2.classList.add('inactive');
          button2.innerHTML = name;
          button2.tabIndex = -1;
          field.appendChild(button2);

          const input = document.createElement('input');
          input.classList.add('input');
          input.classList.add('input-number');
          input.title = 'The controller value';
          input.type = 'number';
          input.min = 0;
          input.max = 127;
          input.value = value || 0;
          input.addEventListener('input', () => {
            if (!inputFine) {
              range.value = input.value;
              MIDI.sendControlChange(Input.channel, controller, input.value);

            } else {
              range.value = (input.value << 7) | inputFine.value;
              MIDI.sendControlChange(Input.channel, controller, input.value);
              MIDI.sendControlChange(Input.channel, MIDI.CC.controllerLSB + controller, inputFine.value);
            }
          });
          field.appendChild(input);

          // Support high-resolution, 14 bits controllers. Controllers 0-31 (MSB)
          // have matching high-resolution values with controllers 32-63 (LSB).
          var inputFine;
          if (valueFine != null) {
            inputFine = document.createElement('input');
            inputFine.classList.add('input');
            inputFine.classList.add('input-number');
            inputFine.title = 'The controller value';
            inputFine.type = 'number';
            inputFine.min = 0;
            inputFine.max = 127;
            inputFine.value = value;
            inputFine.addEventListener('input', () => {
              range.value = (input.value << 7) | inputFine.value;
              MIDI.sendControlChange(Input.channel, controller, input.value);
              MIDI.sendControlChange(Input.channel, MIDI.CC.controllerLSB + controller, inputFine.value);
            });
            field.appendChild(inputFine);
          }

          Input.controllers.elementList.appendChild(field);

          const range = document.createElement('input');
          range.classList.add('range');
          range.title = 'The controller value';
          range.type = 'range';
          if (!inputFine) {
            range.max = 127;
            range.value = value || 0;

          } else {
            range.max = (127 << 7) + 127;
            range.value = (value << 7) + valueFine;
          }
          range.addEventListener('input', () => {
            if (!inputFine) {
              input.value = range.value;
              MIDI.sendControlChange(Input.channel, controller, range.value);

            } else {
              const msb = (range.value >> 7) & 0x7f;
              const lsb = range.value & 0x7f;
              input.value = msb;
              inputFine.value = lsb;
              MIDI.sendControlChange(Input.channel, controller, msb);
              MIDI.sendControlChange(Input.channel, MIDI.CC.controllerLSB + controller, lsb);
            }
          });

          Input.controllers.elementList.appendChild(range);
        }

        function addControllers(controllers) {
          controllers.forEach((controller, index) => {
            addController(controller.name, controller.number, controller.value || 0, controller.valueFine);
          });

          Input.controllers.element.style.display = '';
        }

        // Draw keyboard-like rows of octaves.
        function addKeyboard(start, count) {
          function addOctave(octave, first, last) {
            const field = document.createElement('div');
            field.classList.add('field');
            field.classList.add('has-addons');

            for (let i = 0; i < 12; i++) {
              const button = document.createElement('button');
              button.classList.add('button');
              button.classList.add('button-keyboard');

              const note = (octave * 12) + i;
              button.innerHTML = MIDI.Note.name(note);
              if (MIDI.Note.isBlack(note))
                button.classList.add('is-dark');

              button.title = '#' + note;

              button.addEventListener('mousedown', () => {
                MIDI.sendNoteOn(Input.channel, note, Input.notes.controls.velocity);
              });
              button.addEventListener('mouseup', () => {
                MIDI.sendNoteOff(Input.channel, note);
              });
              button.addEventListener('touchstart', (event) => {
                button.classList.add('is-active');
                button.dispatchEvent(new MouseEvent('mousedown'));
                if (event.cancelable)
                  event.preventDefault()
              });
              button.addEventListener('touchend', (event) => {
                button.classList.remove('is-active');
                button.dispatchEvent(new MouseEvent('mouseup'));
                if (event.cancelable)
                  event.preventDefault()
              });

              if (i < first || i > last)
                button.style.visibility = 'hidden';

              field.appendChild(button);
            }

            Input.notes.chromatic.element.appendChild(field);
          }

          const first_octave = Math.trunc(start / 12);
          const last_octave = Math.trunc((start + (count - 1)) / 12);
          addOctave(first_octave, start % 12, Math.min(11, (start % 12) + count - 1));
          if (last_octave > first_octave) {
            for (let i = first_octave + 1; i < last_octave; i++)
              addOctave(i, 0, 11);

            addOctave(last_octave, 0, (start + count - 1) % 12);
          }
        }

        function addNotes(notes) {
          function addNote(name, note) {
            const field = document.createElement('div');
            field.classList.add('field');
            field.classList.add('has-addons');

            const button = document.createElement('button');
            button.classList.add('button');
            button.classList.add('button-field');
            button.classList.add('inactive');
            button.innerHTML = MIDI.Note.name(note);
            if (MIDI.Note.isBlack(note)) {
              button.classList.add('has-background-grey');
              button.classList.add('has-text-white');
            } else
              button.classList.add('has-background-grey-lighter');
            field.appendChild(button);

            const button2 = document.createElement('button');
            button2.classList.add('button');
            button2.classList.add('button-text');
            button2.innerHTML = name;
            button2.title = '#' + note;
            button2.addEventListener('mousedown', () => {
              MIDI.sendNoteOn(Input.channel, note, Input.notes.controls.velocity);
            });
            button2.addEventListener('mouseup', () => {
              MIDI.sendNoteOff(Input.channel, note);
            });
            button2.addEventListener('touchstart', (event) => {
              button2.classList.add('is-active');
              button2.dispatchEvent(new MouseEvent('mousedown'));
              if (event.cancelable)
                event.preventDefault()
            });
            button2.addEventListener('touchend', (event) => {
              button2.classList.remove('is-active');
              button2.dispatchEvent(new MouseEvent('mouseup'));
              if (event.cancelable)
                event.preventDefault()
            });
            field.appendChild(button2);

            Input.notes.elementList.appendChild(field);
          }

          notes.forEach((note) => {
            addNote(note.name, note.number);
          });
        }

        function addCalibration(start, count, calibrationData) {
          function addCalibrationNote(i, note) {
            const field = document.createElement('div');
            field.classList.add('field');
            field.classList.add('has-addons');

            const button = document.createElement('button');
            button.classList.add('button');
            button.classList.add('button-note');
            button.classList.add('inactive');
            button.innerHTML = MIDI.Note.name(note);
            if (MIDI.Note.isBlack(note)) {
              button.classList.add('has-background-grey');
              button.classList.add('has-text-white');
            } else
              button.classList.add('has-background-grey-lighter');
            button.tabIndex = -1;
            field.appendChild(button);

            const button1 = document.createElement('button');
            button1.classList.add('button');
            button1.classList.add('button-field');
            button1.title = 'Play note #' + note + ' with velocity 1';
            button1.innerHTML = 'Min';
            button1.addEventListener('mousedown', () => {
              MIDI.sendProgramChange(Input.channel, Input.notes.calibration.program);
              MIDI.sendNoteOn(Input.channel, note, Input.notes.calibration.values[i].min);
              MIDI.sendProgramChange(Input.channel, Input.controls.program);
            });
            field.appendChild(button1);

            const inputMin = document.createElement('input');
            inputMin.classList.add('input');
            inputMin.classList.add('input-number');
            inputMin.title = 'The raw value to play note #' + note + ' with velocity 1';
            inputMin.type = 'number';
            inputMin.min = 1;
            inputMin.max = 127;
            inputMin.value = Input.notes.calibration.values[i].min;
            inputMin.addEventListener('change', () => {
              Input.notes.calibration.values[i].min = inputMin.value
              MIDI.sendProgramChange(Input.channel, Input.notes.calibration.program);
              MIDI.sendNoteOn(Input.channel, note, inputMin.value);
              MIDI.sendProgramChange(Input.channel, Input.controls.program);
            });
            field.appendChild(inputMin);

            const button127 = document.createElement('button');
            button127.classList.add('button');
            button127.classList.add('button-field');
            button127.title = 'Play note #' + note + ' with velocity 127';
            button127.innerHTML = 'Max';
            button127.addEventListener('mousedown', () => {
              MIDI.sendProgramChange(Input.channel, Input.notes.calibration.program);
              MIDI.sendNoteOn(Input.channel, note, Input.notes.calibration.values[i].max);
              MIDI.sendProgramChange(Input.channel, Input.controls.program);
            });
            field.appendChild(button127);

            const inputMax = document.createElement('input');
            inputMax.classList.add('input');
            inputMax.classList.add('input-number');
            inputMax.title = 'The raw value to play the note #' + note + ' with velocity 127';
            inputMax.type = 'number';
            inputMax.min = 1;
            inputMax.max = 127;
            inputMax.value = Input.notes.calibration.values[i].max;
            inputMax.addEventListener('change', () => {
              Input.notes.calibration.values[i].max = inputMax.value;
              MIDI.sendProgramChange(Input.channel, Input.notes.calibration.program);
              MIDI.sendNoteOn(Input.channel, note, inputMax.value);
              MIDI.sendProgramChange(Input.channel, Input.controls.program);
            });
            field.appendChild(inputMax);

            Input.notes.calibration.elementNotes.appendChild(field);
          }

          Input.notes.calibration.values = [];
          for (let i = 0; i < count; i++) {
            Input.notes.calibration.values.push({
              'min': calibrationData[i].min,
              'max': calibrationData[i].max
            });
          }

          for (let i = 0; i < count; i++)
            addCalibrationNote(i, start + i);
        }

        function addChannel(channel) {
          // Program change FIMXE: legacy.
          if (channel.program && channel.program.names && channel.program.current != null) {
            const field = document.createElement('div');
            field.classList.add('field');
            field.classList.add('has-addons');

            const button = document.createElement('button');
            button.classList.add('button');
            button.classList.add('button-text');
            button.classList.add('inactive');
            button.classList.add('has-background-grey-lighter');
            button.innerHTML = 'Program #' + (channel.program.current + 1);
            button.tabIndex = -1;
            field.appendChild(button);

            const divselect = document.createElement('div');
            divselect.classList.add('select');
            field.appendChild(divselect);

            const select = document.createElement('select');
            select.title = 'Send MIDI Program Change';
            divselect.appendChild(select);

            channel.program.names.forEach((name, index) => {
              const option = document.createElement('option');
              option.title = '#' + (index + 1);
              option.value = index;
              option.text = name;
              option.selected = (index == channel.program.current);
              select.appendChild(option);
            });

            select.addEventListener('change', () => {
              button.innerHTML = 'Program #' + (select.selectedIndex + 1);
              Input.controls.program = select.selectedIndex;
              MIDI.sendProgramChange(Input.channel, select.selectedIndex);
              Device.sendRequest();
            });

            Input.controls.program = channel.program.current;
            Input.controls.element.appendChild(field);
          }

          // Program change.
          if (channel.programs) {
            // Look for the currently selected program number.
            channel.programs.find((program) => {
              if (!program.selected)
                return false;

              Input.controls.program = program.number;
              return true;
            });

            const field = document.createElement('div');
            field.classList.add('field');
            field.classList.add('has-addons');

            const button = document.createElement('button');
            button.classList.add('button');
            button.classList.add('button-text');
            button.classList.add('inactive');
            button.classList.add('has-background-grey-lighter');
            button.innerHTML = 'Program #' + (Input.controls.program + 1);
            button.tabIndex = -1;
            field.appendChild(button);

            const divselect = document.createElement('div');
            divselect.classList.add('select');
            field.appendChild(divselect);

            const select = document.createElement('select');
            select.title = 'Send MIDI Program Change';
            divselect.appendChild(select);

            channel.programs.forEach((program, index) => {
              const option = document.createElement('option');
              option.title = '#' + (program.number + 1);
              option.value = program.number;
              option.text = program.name;
              option.selected = (program.number == Input.controls.program);
              select.appendChild(option);
            });

            select.addEventListener('change', () => {
              button.innerHTML = 'Program #' + (channel.programs[select.selectedIndex].number + 1);
              Input.controls.program = channel.programs[select.selectedIndex].number;
              MIDI.sendProgramChange(Input.channel, channel.programs[select.selectedIndex].number);
              Device.sendRequest();
            });

            Input.controls.element.appendChild(field);
          }

          // Controllers Section.
          if (channel.controllers)
            addControllers(channel.controllers);

          // Notes Section.
          if (channel.chromatic || channel.notes) {
            const field = document.createElement('div');
            field.classList.add('field');
            field.classList.add('has-addons');

            const button = document.createElement('button');
            button.classList.add('button');
            button.classList.add('button-field');
            button.classList.add('has-background-grey-lighter');
            button.classList.add('inactive');
            button.innerHTML = 'Velocity';
            button.tabIndex = -1;
            field.appendChild(button);

            const input = document.createElement('input');
            input.classList.add('input');
            input.classList.add('input-number');
            input.title = 'The velocity value to play the notes with';
            input.type = 'number';
            input.min = 1;
            input.max = 127;
            input.value = Input.notes.controls.velocity;
            input.addEventListener('input', () => {
              Input.notes.controls.velocity = Number(input.value);
              range.value = input.value;
            });
            field.appendChild(input);

            Input.notes.controls.element.appendChild(field);

            const range = document.createElement('input');
            range.classList.add('range');
            range.title = 'The velocity value to play the notes with';
            range.type = 'range';
            range.min = 1;
            range.max = 127;
            range.value = Input.notes.controls.velocity;
            range.addEventListener('input', () => {
              Input.notes.controls.velocity = Number(range.value);
              input.value = range.value;
            });

            Input.notes.controls.element.appendChild(range);

            // Aftertouch Channel.
            if (channel.aftertouch) {
              const field = document.createElement('div');
              field.classList.add('field');
              field.classList.add('has-addons');

              const button = document.createElement('button');
              button.classList.add('button');
              button.classList.add('button-field');
              button.classList.add('has-background-grey-lighter');
              button.classList.add('inactive');
              button.innerHTML = 'Aftertouch';
              button.tabIndex = -1;
              field.appendChild(button);

              const input = document.createElement('input');
              input.classList.add('input');
              input.classList.add('input-number');
              input.title = 'Channel Aftertouch';
              input.type = 'number';
              input.min = 0;
              input.max = 127;
              input.value = channel.aftertouch.value;
              input.addEventListener('input', () => {
                MIDI.sendAftertouchChannel(Input.channel, Number(input.value));
                range.value = input.value;
              });
              field.appendChild(input);

              Input.notes.controls.element.appendChild(field);

              const range = document.createElement('input');
              range.classList.add('range');
              range.title = 'Channel Aftertouch';
              range.type = 'range';
              range.min = 0;
              range.max = 127;
              range.value = channel.aftertouch.value;
              range.addEventListener('input', () => {
                MIDI.sendAftertouchChannel(Input.channel, Number(range.value));
                input.value = range.value;
              });

              range.addEventListener('mouseup', () => {
                range.value = 0;
                input.value = 0;
                MIDI.sendAftertouchChannel(Input.channel, 0);
              });

              range.addEventListener('touchend', (event) => {
                rangeange.dispatchEvent(new MouseEvent('mouseup'));
                if (event.cancelable)
                  event.preventDefault()
              });

              Input.notes.controls.element.appendChild(range);
            }

            // Pitch Bend.
            if (channel.pitchbend) {
              const field = document.createElement('div');
              field.classList.add('field');
              field.classList.add('has-addons');

              const button = document.createElement('button');
              button.classList.add('button');
              button.classList.add('button-field');
              button.classList.add('has-background-grey-lighter');
              button.classList.add('inactive');
              button.innerHTML = channel.pitchbend.name || 'Pitch Bend';
              button.tabIndex = -1;
              field.appendChild(button);

              const input = document.createElement('input');
              input.classList.add('input');
              input.classList.add('input-number');
              input.title = 'Pitch Bend';
              input.type = 'number';
              input.min = -8192;
              input.max = 8191;
              input.value = channel.pitchbend.value;
              input.addEventListener('input', () => {
                MIDI.sendPitchBend(Input.channel, Number(input.value));
                range.value = input.value;
              });
              field.appendChild(input);

              Input.notes.controls.element.appendChild(field);

              const range = document.createElement('input');
              range.classList.add('range');
              range.title = 'Pitch Bend';
              range.type = 'range';
              range.min = -8192;
              range.max = 8191;
              range.value = channel.pitchbend.value;
              range.addEventListener('input', () => {
                MIDI.sendPitchBend(Input.channel, Number(range.value));
                input.value = range.value;
              });

              range.addEventListener('mouseup', () => {
                // Do not reset value to 0 if pitchbend is used for something else.
                if (channel.pitchbend.name != null)
                  return;
                range.value = 0;
                input.value = 0;
                MIDI.sendPitchBend(Input.channel, 0);
              });

              range.addEventListener('touchend', (event) => {
                rangeange.dispatchEvent(new MouseEvent('mouseup'));
                if (event.cancelable)
                  event.preventDefault()
              });

              Input.notes.controls.element.appendChild(range);
            }

            // A range of chromatic notes.
            if (channel.chromatic) {
              const chromatic = channel.chromatic;

              // Range of chromatic notes.
              Input.notes.chromatic.start = chromatic.start;
              Input.notes.chromatic.count = chromatic.count;
              addKeyboard(Input.notes.chromatic.start, Input.notes.chromatic.count);

              // Calibration editor to tune velocity range.
              if (chromatic.calibration && calibrationData) {
                const calibration = chromatic.calibration;

                if (calibration.program != null) {
                  Input.notes.calibration.program = calibration.program;

                  if (calibrationNotify)
                    Input.notes.calibration.notify.success('Calibration updated.');

                  addCalibration(Input.notes.chromatic.start, Input.notes.chromatic.count, calibrationData);
                  Input.notes.calibration.element.style.display = '';
                }
              }
            }

            // A list of individual notes.
            if (channel.notes)
              addNotes(channel.notes);

            Input.notes.element.style.display = '';
          }
        }

        function addChannels(channels) {
          const field = document.createElement('div');
          field.classList.add('field');
          field.classList.add('has-addons');

          const button = document.createElement('button');
          button.classList.add('button');
          button.classList.add('button-text');
          button.classList.add('inactive');
          button.classList.add('has-background-grey-lighter');
          button.innerHTML = 'Channel #' + (Input.channel + 1);
          button.tabIndex = -1;
          field.appendChild(button);

          const divselect = document.createElement('div');
          divselect.classList.add('select');
          field.appendChild(divselect);

          const select = document.createElement('select');
          select.title = 'MIDI Channel';
          divselect.appendChild(select);

          // Look for the currently selected channel number.
          channels.find((channel) => {
            if (!channel.selected)
              return false;

            Input.channel = channel.number;
            return true;
          });

          channels.forEach((channel, index) => {
            const option = document.createElement('option');
            option.title = '#' + (channel.number + 1);
            option.value = index;
            option.text = (channel.number + 1);
            if (channel.name)
              option.text += ' - ' + channel.name;
            option.selected = (channel.number == Input.channel);
            select.appendChild(option);
          });

          select.addEventListener('change', () => {
            button.innerHTML = 'Channel #' + (channels[select.selectedIndex].number + 1);
            Input.channel = channels[select.selectedIndex].number;
            // Request a refresh with the values of the selected channel.
            MIDI.sendSystemExclusive({
              'com.versioduo.device': {
                'method': 'switchChannel',
                'channel': channels[select.selectedIndex].number
              }
            });
          });

          const refresh = document.createElement('button');
          refresh.classList.add('button');
          refresh.classList.add('is-primary');
          refresh.data = "Refresh data";
          refresh.innerHTML = "Refresh";
          refresh.addEventListener('click', () => {
            Device.sendRequest();
          });
          field.appendChild(refresh);

          Input.controls.element.appendChild(field);

          channels.find((channel) => {
            if (channel.number != Input.channel)
              return false;

            addChannel(channel);
            return true;
          });
        }

        const calibrationNotify = this.notes.calibration.timeout != null;

        this.clear();

        if (!data)
          return;

        // The controls for all channels.
        addChannel(data);

        // A separate set of controls per channel.
        if (data.channels)
          addChannels(data.channels)
      },

      clear: function() {
        this.notes.controls.velocity = 15;

        this.controllers.element.style.display = 'none';

        this.controls.program = null;

        while (this.controls.element.firstChild)
          this.controls.element.firstChild.remove();

        while (this.controllers.elementList.firstChild)
          this.controllers.elementList.firstChild.remove();

        this.notes.element.style.display = 'none';

        while (this.notes.controls.element.firstChild)
          this.notes.controls.element.firstChild.remove();

        while (this.notes.chromatic.element.firstChild)
          this.notes.chromatic.element.firstChild.remove();

        while (this.notes.elementList.firstChild)
          this.notes.elementList.firstChild.remove();

        if (this.notes.calibration) {
          const calibration = this.notes.calibration;
          if (calibration.timeout) {
            clearTimeout(calibration.timeout);
            calibration.timeout = null;
          }
          calibration.notify.clear();

          calibration.element.style.display = 'none';
          calibration.values = null;
          while (calibration.elementNotes.firstChild)
            calibration.elementNotes.firstChild.remove();
        }
      },

      disconnect: function() {
        this.channel = 0;
        this.clear();
      },

      sendCalibration: function() {
        Log.printDevice(MIDI.deviceOutput, 'Calling <b>writeConfiguration()</b>');
        MIDI.sendSystemExclusive({
          'com.versioduo.device': {
            'method': 'writeConfiguration',
            'configuration': {
              'calibration': this.notes.calibration.values
            }
          }
        });

        Device.setEnabled(false);

        function handler() {
          Input.notes.calibration.timeout = null;
          Input.notes.calibration.notify.error('No reply from device. Calibration might not be not saved.');
          Log.printDevice(MIDI.deviceInput, 'No reply from device');
          Device.setEnabled(true);
        }
        this.notes.calibration.timeout = setTimeout(handler, 1000);
      },

      playAll: function() {
        if (Input.notes.calibration.program == null)
          return;

        this.notes.calibration.playAllIndex = 0;
        MIDI.sendProgramChange(Input.channel, Input.notes.calibration.program);

        function handler() {
          const calibration = Input.notes.calibration;
          const note = calibration.playAllIndex + Input.notes.chromatic.start;
          const velocity = calibration.values[calibration.playAllIndex].min;
          MIDI.sendNoteOn(Input.channel, note, velocity);

          calibration.playAllIndex++;
          if (calibration.playAllIndex < calibration.values.length)
            setTimeout(handler, 100);

          else
            MIDI.sendProgramChange(Input.channel, Input.program);
        }
        setTimeout(handler, 100);
      }
    })
  </script>







  <!-- MIDI Out, receive notes -->
  <section class="section">
    <span id="output" class="offset"></span>
    <div class="container">
      <h2 class="title">
        MIDI Out
      </h2>
      <p class="subtitle">
        Receive notes and control changes
      </p>
      <div id="outputChannel" style="display:none">
        <div class="field has-addons">
          <button class="button button-field has-background-grey-lighter inactive">Channel</button>
          <button id="outputChannelValue" class="button button-number inactive"></button>
        </div>
      </div>
      <div id="outputControllers" class="subsection" style="display:none">
        <h3 class="title">
          Controllers
        </h3>
        <div id="outputControllersList"></div>
      </div>
      <div id="outputNotes" class="subsection" style="display:none">
        <h3 class="title">
          Notes
        </h3>
        <div id="outputNotesList"></div>
      </div>
    </div>
  </section>
  <script>
    'use strict';

    const Output = Object.seal({
      channel: {
        element: document.getElementById('outputChannel'),
        elementValue: document.getElementById('outputChannelValue'),
        value: null
      },
      controllers: {
        element: document.getElementById('outputControllers'),
        elementList: document.getElementById('outputControllersList'),
        list: null
      },
      notes: {
        element: document.getElementById('outputNotes'),
        elementList: document.getElementById('outputNotesList'),
        list: null
      },

      show: function(data) {
        function addController(name, controller, value, valueFine) {
          const field = document.createElement('div');
          field.classList.add('field');
          field.classList.add('has-addons');

          const button = document.createElement('button');
          button.classList.add('button');
          button.classList.add('button-field');
          button.classList.add('has-background-grey-lighter');
          button.classList.add('inactive');
          button.innerHTML = 'CC #' + controller;
          field.appendChild(button);

          const button2 = document.createElement('button');
          button2.classList.add('button');
          button2.classList.add('button-text');
          button2.classList.add('inactive');
          button2.innerHTML = name;
          field.appendChild(button2);

          const input = document.createElement('input');
          input.classList.add('input');
          input.classList.add('input-number');
          input.classList.add('inactive');
          input.type = 'number';
          input.value = value || 0;
          field.appendChild(input);

          // Support high-resolution, 14 bits controllers. Controllers 0-31 (MSB)
          // have matching high-resolution values with controllers 32-63 (LSB).
          if (valueFine != null) {
            const inputFine = document.createElement('input');
            inputFine.classList.add('input');
            inputFine.classList.add('input-number');
            inputFine.classList.add('inactive');
            inputFine.type = 'number';
            inputFine.value = valueFine;
            field.appendChild(inputFine);

            Output.controllers.list[controller + MIDI.CC.controllerLSB] = {
              'input': inputFine
            };
          }

          Output.controllers.elementList.appendChild(field);

          const progress = document.createElement('progress');
          progress.classList.add('progress');
          progress.classList.add('is-small');
          progress.value = value || 0;
          progress.max = '127';
          Output.controllers.elementList.appendChild(progress);

          Output.controllers.list[controller] = {
            'input': input,
            'progress': progress
          };
        }

        function addNote(name, note, hasAftertouch) {
          const field = document.createElement('div');
          field.classList.add('field');
          field.classList.add('has-addons');

          const button = document.createElement('button');
          button.classList.add('button');
          button.classList.add('button-field');
          button.classList.add('inactive');
          button.innerHTML = MIDI.Note.name(note);
          if (MIDI.Note.isBlack(note)) {
            button.classList.add('has-background-grey');
            button.classList.add('has-text-white');
          } else
            button.classList.add('has-background-grey-lighter');
          field.appendChild(button);

          const button2 = document.createElement('button');
          button2.classList.add('button');
          button2.classList.add('button-text');
          button2.classList.add('inactive');
          button2.innerHTML = name;
          field.appendChild(button2);

          const input = document.createElement('input');
          input.classList.add('input');
          input.classList.add('input-number');
          input.classList.add('inactive');
          input.title = 'Velocity';
          input.type = 'number';
          field.appendChild(input);

          Output.notes.elementList.appendChild(field);

          const progress = document.createElement('progress');
          progress.classList.add('progress');
          progress.classList.add('is-small');
          progress.value = '0';
          progress.max = '127';
          Output.notes.elementList.appendChild(progress);

          Output.notes.list[note] = {
            'input': input,
            'progress': progress
          }

          if (hasAftertouch) {
            const aftertouch = document.createElement('progress');
            aftertouch.classList.add('progress');
            aftertouch.classList.add('is-small');
            aftertouch.value = '0';
            aftertouch.max = '127';
            Output.notes.elementList.appendChild(aftertouch);

            Output.notes.list[note].aftertouch = aftertouch;
          }
        }

        this.clear();

        if (!data)
          return;

        if (data.channel != null) {
          this.channel.elementValue.innerHTML = data.channel + 1;
          this.channel.element.style.display = '';
          this.channel.value = data.channel;
        }

        if (data.controllers) {
          this.controllers.list = {};
          data.controllers.forEach((controller) => {
            addController(controller.name, controller.number, controller.value, controller.valueFine);
          });

          this.controllers.element.style.display = '';
        }

        if (data.notes) {
          this.notes.list = {};
          data.notes.forEach((note) => {
            addNote(note.name, note.number, note.aftertouch);
          });

          this.notes.element.style.display = '';
        }
      },

      updateController: function(channel, controller, value) {
        if (this.channel.value != null && this.channel.value != channel)
          return;

        if (!this.controllers.list || !this.controllers.list[controller])
          return;

        this.controllers.list[controller].input.value = value;
        if (this.controllers.list[controller].progress)
          this.controllers.list[controller].progress.value = value;
      },

      updateNote: function(channel, note, velocity) {
        if (this.channel.value != null && this.channel.value != channel)
          return;

        if (!this.notes.list || !this.notes.list[note])
          return;

        if (velocity > 0) {
          this.notes.list[note].input.value = velocity;
          this.notes.list[note].progress.value = velocity;

        } else {
          this.notes.list[note].input.value = null;
          this.notes.list[note].progress.value = 0;
          if (this.notes.list[note].aftertouch)
            this.notes.list[note].aftertouch.value = 0;
        }
      },

      updateNoteAftertouch: function(channel, note, pressure) {
        if (this.channel.value != null && this.channel.value != channel)
          return;

        if (!this.notes.list[note] || !this.notes.list[note].aftertouch)
          return;

        this.notes.list[note].aftertouch.value = pressure;
      },

      clear: function() {
        this.channel.element.style.display = 'none';

        this.controllers.element.style.display = 'none';
        this.controllers.list = null;
        while (this.controllers.elementList.firstChild)
          this.controllers.elementList.firstChild.remove();

        this.notes.element.style.display = 'none';
        this.notes.list = null;
        while (this.notes.elementList.firstChild)
          this.notes.elementList.firstChild.remove();
      },

      disconnect: function() {
        this.clear();
      }
    })
  </script>

  <!-- Configuration editor -->
  <section class="section">
    <span id="configuration" class="offset"></span>
    <div class="container">
      <h2 class="title">
        Configuration
      </h2>
      <p class="subtitle">
        The stored settings
      </p>
      <div class="field has-addons">
        <button class="button isEnabled " title="Write this configuration to a file" disabled onclick="Configuration.save();">Export</button>
        <button class="button isEnabled" title="Read a configuration from a file" disabled onclick="Configuration.open();">Import</button>
        <button class="button isEnabled" title="Reset everything to defaults and reboot the device" disabled onclick="Configuration.erase();">Erase</button>
        <button class="button isEnabled is-primary" title="Store this configuration in the device" disabled onclick="Configuration.send();">Save</button>
      </div>
      <div id="configurationNotify"></div>
      <textarea id="configurationJSON" class="textarea isEnabled" placeholder="No configuration loaded" rows="1" onclick="Configuration.expand(event);" disabled></textarea>
    </div>
  </section>
  <script>
    'use strict';

    // Textarea containing the JSON formatted configuration of the device. The content
    // is parsed and reformatted when an action is requested. The JSON object can be saved
    // to and loaded from disk.
    const Configuration = Object.seal({
      notify: new Notify(document.getElementById('configurationNotify')),
      timeout: null,
      maximized: false,
      elementJSON: document.getElementById('configurationJSON'),

      resize: function() {
        const lines = this.elementJSON.value.split('\n').length;
        if (this.maximized) {
          this.elementJSON.rows = lines;

        } else {
          this.elementJSON.style.height = 'initial';
          this.elementJSON.rows = Math.min(5, lines);
        }
      },

      // Click to maximize, triple-click to minimize.
      expand: function(event) {
        if (this.maximized && event.detail == 3) {
          this.elementJSON.setSelectionRange(1, 1);
          this.maximized = false;

        } else if (!this.maximized)
          this.maximized = true;

        this.resize();
      },

      show: function(json) {
        const notify = this.timeout != null;
        this.clear();
        if (notify)
          this.notify.success('Configuration updated.');

        this.elementJSON.value = JSON.stringify(json, null, '  ');
        this.resize();
        this.elementJSON.disabled = false;
      },

      clear: function() {
        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        this.notify.clear();
        this.elementJSON.value = '';
        this.maximized = false;
        this.resize();
      },

      // Parse the JSON text field and reformat it.
      parse: function() {
        let configuration;

        try {
          configuration = JSON.parse(this.elementJSON.value);

        } catch (error) {
          this.notify.warn(error.toString());

          // Try to find the position in the error string and place the cursor.
          const match = error.toString().match(/position (\d+)/);
          if (match) {
            const position = Number(match[1]);
            this.elementJSON.setSelectionRange(position, position + 1);
          }
          this.elementJSON.focus();
          Log.print('Configuration <b>Invalid JSON</b>: ' + error);
          return;
        }

        this.show(configuration);
        return configuration;
      },

      // Save the current JSON text field to a file.
      save: function() {
        const configuration = this.parse();
        if (!configuration)
          return;

        const date = new Date();
        const config = {
          '#': 'Device configuration export',
          'vendor': Device.info.metadata.vendor,
          'product': Device.info.metadata.product,
          'version': Device.info.metadata.version,
          'creator': window.location.href,
          'date': date.toISOString(),
          'configuration': configuration
        };

        const json = JSON.stringify(config, null, '  ');
        let name = Device.info.metadata.product;
        if (Device.info.metadata.name)
          name += '-' + Device.info.metadata.name;
        name += '.json';

        // Temporarily create an anchor and download the file as URI.
        const a = document.createElement('a');
        a.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(json));
        a.setAttribute('download', name.replace(/ /g, '-'));
        a.style.display = 'none';
        a.click();
      },

      // Load a JSON file into the text field.
      open: function() {
        // Temporarily create a 'browse button' and trigger a file upload.
        const input = document.createElement('input');
        input.setAttribute('type', 'file');
        input.setAttribute('accept', '.json,.txt,.conf');
        input.style.display = 'none';
        document.body.appendChild(input);

        input.addEventListener('change', () => {
          const reader = new FileReader();
          reader.onload = function(element) {
            let config;

            try {
              config = JSON.parse(reader.result);

            } catch (error) {
              Configuration.notify.warn('Unable to parse JSON from file');
              return;
            }

            if (!config.configuration) {
              Configuration.notify.warn('No valid configuration found in file');
              return;
            }

            const json = JSON.stringify(config.configuration, null, '  ');
            Configuration.elementJSON.value = json;
            Configuration.parse();
          };

          reader.readAsText(input.files[0]);
          input.remove();
        });

        input.click();

        this.maximized = true;
        this.resize();
      },

      // Send the configuration to the device.
      send: function() {
        const data = this.parse();
        if (data) {
          Log.printDevice(MIDI.deviceOutput, 'Calling <b>writeConfiguration()</b>');
          MIDI.sendSystemExclusive({
            'com.versioduo.device': {
              'method': 'writeConfiguration',
              'configuration': data
            }
          });

          Device.setEnabled(false);

          function handler() {
            Configuration.timeout = null;
            Configuration.notify.error('No reply from device. Configuration might not be not saved.');
            Log.printDevice(MIDI.deviceInput, 'No reply from device');
            Device.setEnabled(true);
          }
          this.timeout = setTimeout(handler, 1000);
        }
      },

      // Factory reset.
      erase: function() {
        Log.printDevice(MIDI.deviceOutput, 'Calling <b>eraseConfiguration()</b> command');
        MIDI.sendSystemExclusive({
          'com.versioduo.device': {
            'method': 'eraseConfiguration'
          }
        });

        MIDI.disconnectDevice();
      }
    })
  </script>



  <!-- System log viewer -->
  <section class="section">
    <span id="log" class="offset"></span>
    <div class="container">
      <h2 class="title">
        Log
      </h2>
      <p class="subtitle">
        View system events
      </p>
      <div class="field has-addons">
        <button class="button" title="Print all available MIDI ports" onclick="MIDI.printStatus();">Status</button>
        <button class="button" title="Clear this log" onclick="Log.clear();">Clear</button>
      </div>
      <div id="logHTML" class="log content is-small"></div>
    </div>
  </section>
  <script>
    'use strict';

    // Div showing HTML formatted log messages.
    const Log = Object.seal({
      element: document.getElementById('logHTML'),
      lines: [],
      refresh: false,
      timeout: null,

      print: function(line) {
        this.lines.push(line);
        if (this.lines.length > 25)
          this.lines.shift();

        this.refresh = true;

        if (this.timeout)
          return;

        this.update();

        // Set timout to rate-limit the updating.
        this.timeout = setTimeout(() => {
          this.timeout = null;
          this.update();
        }, 250);
      },

      update: function() {
        if (!this.refresh)
          return;

        this.refresh = false;

        this.element.innerHTML = '';
        this.lines.forEach((line) => {
          this.element.innerHTML += line + '<br>\n';
        });

        this.element.scrollTop = this.element.scrollHeight;
      },

      clear: function() {
        this.lines = [];
        this.element.innerHTML = '';
      },

      printDevice: function(device, line) {
        if (device)
          this.print('Device <b>' + device.name + '</b> (' + device.id + '): ' + line);

        else
          this.print('Device <b>n/a</b>: ' + line);
      }
    })
  </script>

  <script>
    'use strict';

    MIDI.setup();
  </script>
</body>

</html>
